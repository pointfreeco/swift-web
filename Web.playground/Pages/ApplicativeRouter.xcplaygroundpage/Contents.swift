import ApplicativeRouter
import Either
import Foundation
import Prelude

/*:
 First we define a `Route` enum that defines all the different pages a user can visit in our site. Here
 we have defined 3 pages:

 - The home page
 - An "Episodes" page that lists all of the episodes available. It also takes an optional query param that
   determines how the episodes should be ordered.
 - An "Episode" page that shows a particular episode. An episode can be found by either looking up its
   slug or its id, and an optional ref tag can be attached to the query param so that we can track how
   visitors are coming to the site.
 */
enum Route {
  // e.g. /
  case home

  // e.g. /episodes?order=asc
  case episodes(order: Order?)

  // e.g. /episodes/intro-to-functions?ref=twitter
  case episode(param: Either<String, Int>, ref: String?)
}

/*:
 The enum that determines how to order episodes.
 */
enum Order: String {
  case asc
  case desc
}

/*:
 A small amount of boilerplate needed to use the router. Each case of the route enum needs two functions:
 one for extracting associated values out of the cases, and one for putting associated values into the enum.
 Fortunately Swift automatically generates one of these functions for us, for if an enum `Foo` has a case
 of the form `case bar(Int)`, Swift generates a function `Foo.bar: (Int) -> Foo`, which takes the associated
 value as input, and produces a value of the enum.

 Maybe someday Swift will also generate the other direction of this function, i.e. given a value of the enum,
 optionally extract out the associated value.

 This code can also be easily generated by a tool like Sourcery.
 */
extension Route {
  enum iso {
    static let home = parenthesize <| PartialIso<Prelude.Unit, Route>(
      apply: const(.some(.home)),
      unapply: { if case .home = $0 { return unit } else { return nil } }
    )

    static let episodes = parenthesize <| PartialIso(
      apply: Route.episodes,
      unapply: {
        guard case let .episodes(result) = $0 else { return nil }
        return result
    })

    static let episode = parenthesize <| PartialIso(
      apply: Route.episode,
      unapply: {
        guard case let .episode(result) = $0 else { return nil }
        return result
    })
  }
}

/*:
 And now we can create our router, i.e. the thing that describes how a `URLRequest` relates to a value of the
 `Route` enum. The `ApplicativeRouter` library comes with lots of combinators that allow you to express
 most of what you would want to match against.
 */
let router = [

  Route.iso.home
    <¢> get <% end,

  Route.iso.episodes
    <¢> get %> lit("episodes")
    %> queryParam("order", opt(.rawRepresentable))
    <% end,

  Route.iso.episode
    <¢> get %> lit("episodes") %> pathParam(.intOrString)
    <%> queryParam("ref", opt(.string))
    <% end

  ]
  .reduce(.empty, <|>)

/*:
 And now let's play with the router!

 First we can try matching some URL's with the router and see that they produce a `Route` value:
 */
router.match(string: "/")
router.match(string: "/episodes")
router.match(string: "/episodes?order=asc")
router.match(string: "/episodes?order=xyz")
router.match(string: "/episodes/42")
router.match(string: "/episodes/intro-to-funcs")
router.match(string: "/episodes/intro-to-funcs?ref=twitter")

/*:
 And we can generate urls for `Route` values that would get routed to that value. Great for type-safe URL
 helpers!
 */
router.absoluteString(for: .episodes(order: nil))
router.absoluteString(for: .episodes(order: .asc))
router.absoluteString(for: .home)
router.absoluteString(for: .episode(param: .left("intro-to-funcs"), ref: nil))
router.absoluteString(for: .episode(param: .left("intro-to-funcs"), ref: "twitter"))
router.absoluteString(for: .episode(param: .right(42), ref: nil))

/*:
 This is what happens if you try to match a URL that the router doesn't recognize:
 */
router.match(string: "/does-not-exist")

print("✅")
